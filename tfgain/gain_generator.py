import tensorflow as tf

class GAINGenerator(object):
    """This is class to impute missing value with proper values from
    observed data and missing mask (0/1 flags indicating missing value)
    """
    def __init__(self):
        pass

    def generate(self, x, m, z):
        """Generate candidate values to be imputated.

        Parameters
        ----------
        x : tf.Tensor of tf.float32
            data frame which is target of missing value imputation.
        m : tf.Tensor of tf.bool
            mask data indicating missing positions in x.
            (if True, observed ; same size as x)
        z : tf.Tensor of tf.float32
            data frame each cell of which has random numbers
            to generate imputed values (same size as x)

        Returns
        -------
        xbar : tf.Tensor of tf.float32
            generated data frame which has candidate values
            (even in observed cell)
        """
        assert x.shape.as_list() == m.shape.as_list() == z.shape.as_list()
        assert x.dtype == z.dtype == tf.float32
        assert m.dtype == tf.bool

        mf = tf.cast(m, dtype=tf.float32, name="mask_float")
        out = tf.concat([x, mf, z], axis=1, name="concat")
        d = x.shape[1]

        out = tf.layers.dense(out, d, activation=tf.tanh, name="dense1")
        out = tf.layers.dense(out, int(int(d)/2), activation=tf.tanh, name="dense2")
        out = tf.layers.dense(out, d, activation=tf.sigmoid, name="dense3")
        return out

    def impute(self, x, xbar, m):
        """Do missing value imputation. This method uses candidate
        values in xbar (which is generated by generate method)

        Parameters
        ----------
        x : tf.Tensor of tf.float32
            data frame which is target of missing value imputation.
        xbar : tf.Tensor of tf.float32
            data frame which is result of generate method.
            all of missing value of x are imputed by candidate values.
            (same size as x)
        m : tf.Tensor of tf.bool
            mask data indicating missing positions (if True, observed)

        Returns
        -------
        xhat : tf.Tensor
            result of missing value imputation of x.
        """
        assert x.shape.as_list() == xbar.shape.as_list() == m.shape.as_list()
        assert x.dtype == xbar.dtype == tf.float32
        assert m.dtype == tf.bool

        xhat = tf.where(m, x, xbar)
        return xhat

    def adversarial_loss(self, mhat, m, b):
        """Calculate adversarial loss. This method compares
        actual missing mask from output of discriminator, and
        uses hint (b).

        Parameters
        ----------
        mhat : tf.Tensor of tf.float32
            A prediction result of missing mask of discriminator.
            It contains probability whether it is observed.
        m : tf.Tensor of tf.bool
            actual missing mask (same size as mhat)
        b : tf.Tensor of tf.bool
            Hint flag data
            each row has only one True, which is selected at random.
            The other cells are False (same size as mhat)

        Returns
        -------
        loss : tf.Tensor of tf.float32 (no dimension)
            adversarial loss calculated
        """
        assert mhat.shape.as_list() == m.shape.as_list() == b.shape.as_list()
        assert mhat.dtype == tf.float32
        assert m.dtype == b.dtype == tf.bool

        eps = 1e-7
        log_loss = - tf.where(m, tf.zeros_like(m, dtype=tf.float32),
                              tf.log(mhat + eps))
        loss = tf.reduce_sum(tf.where(b, tf.zeros_like(b, dtype=tf.float32),
                                      log_loss))

        return loss

    def generate_loss(self, x, xbar, m):
        """Calculate generate loss.
        The more x is similar to xbar, the less loss is.

        Parameters
        ----------
        x : tf.Tensor of tf.float32
            data frame which is target of missing value imputation.
        xbar : tf.Tensor of tf.float32
            data frame which is result of generate method.
            all of missing value of x are imputed by candidate values.
            (same size as x)
        m : tf.Tensor of tf.bool
            mask data indicating missing positions in x by 0/1 flag
            (0=missing, 1=observed ; same size as x)

        Returns
        -------
        loss : tf.Tensor of tf.float32 (no dimension)
            generate loss calculated
        """
        assert x.shape.as_list() == xbar.shape.as_list() == m.shape.as_list()
        assert x.dtype == xbar.dtype == tf.float32
        assert m.dtype == tf.bool

        mse = tf.square(x - xbar)
        loss = tf.reduce_sum(tf.where(m, mse,
                             tf.zeros_like(m, dtype=tf.float32)))

        return loss
